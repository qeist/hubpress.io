<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Kyunam Kevin Kwak's Blog]]></title><description><![CDATA[Kyunam Kevin Kwak's Blog]]></description><link>https://qeist.github.io</link><generator>RSS for Node</generator><lastBuildDate>Tue, 10 Jan 2017 15:48:56 GMT</lastBuildDate><atom:link href="https://qeist.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Introduction to AsciiDoc]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>hyperlink <a href="http://www.naver.com">go to naver</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_first_section">First Section</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>item 1</p>
</li>
<li>
<p>item 2</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts "Hello, World!"</code></pre>
</div>
</div>
</div>
</div>]]></description><link>https://qeist.github.io/2016/12/06/Introduction-to-Ascii-Doc.html</link><guid isPermaLink="true">https://qeist.github.io/2016/12/06/Introduction-to-Ascii-Doc.html</guid><dc:creator><![CDATA[Kyunam Kevin Kwak]]></dc:creator><pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[06. algorithm between intermediate and advance]]></title><link>https://qeist.github.io/2016/12/06/06-algorithm-between-intermediate-and-advance.html</link><guid isPermaLink="true">https://qeist.github.io/2016/12/06/06-algorithm-between-intermediate-and-advance.html</guid><category><![CDATA[#problem solving #algorithm]]></category><dc:creator><![CDATA[Kyunam Kevin Kwak]]></dc:creator><pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[05. algorithm intermediate02]]></title><link>https://qeist.github.io/2016/12/06/05-algorithm-intermediate02.html</link><guid isPermaLink="true">https://qeist.github.io/2016/12/06/05-algorithm-intermediate02.html</guid><category><![CDATA[#problem solving #algorithm]]></category><dc:creator><![CDATA[Kyunam Kevin Kwak]]></dc:creator><pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[04. algorithm intermediate01]]></title><link>https://qeist.github.io/2016/12/06/04-algorithm-intermediate01.html</link><guid isPermaLink="true">https://qeist.github.io/2016/12/06/04-algorithm-intermediate01.html</guid><category><![CDATA[#problem solving #algorithm]]></category><dc:creator><![CDATA[Kyunam Kevin Kwak]]></dc:creator><pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[03. algorithm basic]]></title><link>https://qeist.github.io/2016/12/06/03-algorithm-basic.html</link><guid isPermaLink="true">https://qeist.github.io/2016/12/06/03-algorithm-basic.html</guid><category><![CDATA[#problem solving #algorithm]]></category><dc:creator><![CDATA[Kyunam Kevin Kwak]]></dc:creator><pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[02. problem solving using Java]]></title><link>https://qeist.github.io/2016/12/06/02-problem-solving-using-Java.html</link><guid isPermaLink="true">https://qeist.github.io/2016/12/06/02-problem-solving-using-Java.html</guid><category><![CDATA[#problem solving #algorithm]]></category><dc:creator><![CDATA[Kyunam Kevin Kwak]]></dc:creator><pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[01. problem solving using C++]]></title><description><![CDATA[<div class="sect1">
<h2 id="_pair">pair</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>pair를 사용하면 두 자료형 T1과 T2를 묶을 수 있다</p>
</li>
<li>
<p>항상 두 개를 묶는다</p>
</li>
<li>
<p>첫 번째 자료는 first</p>
</li>
<li>
<p>두 번째 자료는 second로 접근할 수 있다.</p>
</li>
<li>
<p>#include &lt;utility&gt; 에 있는데, algorithm, vector와 같은 헤더파일에서 이미 include 하고 있기 때문에 따로 include 하는 경우는 없다.</p>
</li>
<li>
<p>make_pair를 이용하거나, 생성자를 이용해서 만들 수 있다.</p>
</li>
</ul>
</div>
<div id="app-listing" class="listingblock">
<div class="title">pair_example01.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">pair&lt;int, int&gt; p1;
cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; '\n';

p1 = make_pair(10, 20);
cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; '\n'

p1 = pair&lt;int, int&gt;(30, 40);
cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; '\n'

pair&lt;int, int&gt; p2(50, 60);
cout &lt;&lt; p2.first &lt;&lt; ' ' &lt;&lt; p2.second &lt;&lt; '\n';</code></pre>
</div>
</div>
<div id="app-listing" class="listingblock">
<div class="title">pair_example02.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">pair&lt;pair&lt;int, int&gt;&gt; p = make_pair(make_pair(10, 20), make_pair(30, 40));
cout &lt;&lt; p.first.first &lt;&lt; ' ' &lt;&lt; p.first.second &lt;&lt; ' ';
cout &lt;&lt; p.second.first &lt;&lt; ' ' &lt;&lt; p.second.second &lt;&lt; '\n';</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tuple">tuple</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>tuple은 pair와 같지만 여러 개를 묶을 수 있다</p>
</li>
<li>
<p>.first, .second, .third, .fourth &#8230;&#8203; 가 아니고 get을 이용해서 인덱스로 접근해야 한다</p>
</li>
<li>
<p>tuple은 #include &lt;tuple&gt;에 정의되어 있다</p>
</li>
</ul>
</div>
<div id="app-listing" class="listingblock">
<div class="title">tuple_example01.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">tuple&lt;int, int, int&gt; t1 = make_tuple(1, 2, 3);

cout &lt;&lt; get&lt;0&gt;(t1) &lt;&lt; ' ';
cout &lt;&lt; get&lt;1&gt;(t1) &lt;&lt; ' ';
cout &lt;&lt; get&lt;2&gt;(t1) &lt;&lt; '\n';

/*
for (int i=0; i&lt;3; i++) {
    count &lt;&lt; get&lt;i&gt;(t1) &lt;&lt; '\n';
}
*/</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>get&lt;&gt; 사이에 변수를 넣을 수는 없다</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tie">tie</h2>
<div class="sectionbody">
<div id="app-listing" class="listingblock">
<div class="title">tie_example01.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">auto t = make_tuple(10, 20, 30);

int x = get&lt;0&gt;(t);
int y = get&lt;1&gt;(t);
int z = get&lt;2&gt;(t);

cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; '\n';

x = y = z = 0;

tie(x, y, z) = t; // (10, 20, 30)

cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; '\n';</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>tie는 pair에도 사용할 수 있다.</p>
</li>
<li>
<p>변수값을 무시해야 하는 경우에는 ignore를 사용한다</p>
</li>
</ul>
</div>
<div id="app-listing" class="listingblock">
<div class="title">tie_example02.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">auto t = make_tuple(1, 2, 3);

int x, y;
tie(x, y, ignore) = t; // (1, 2)

cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vector">vector</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_deque">deque</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_list">list</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_set">set</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_map">map</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_stack">stack</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_queue">queue</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_priority_queue">priority_queue</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_bitset">bitset</h2>
<div class="sectionbody">

</div>
</div>]]></description><link>https://qeist.github.io/2016/12/06/01-problem-solving-using-C.html</link><guid isPermaLink="true">https://qeist.github.io/2016/12/06/01-problem-solving-using-C.html</guid><category><![CDATA[#problem solving #algorithm]]></category><dc:creator><![CDATA[Kyunam Kevin Kwak]]></dc:creator><pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate></item></channel></rss>