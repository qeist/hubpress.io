= 01. problem solving using C++
:hp-tags: #problem solving #algorithm

== pair
* pair를 사용하면 두 자료형 T1과 T2를 묶을 수 있다
* 항상 두 개를 묶는다
* 첫 번째 자료는 first
* 두 번째 자료는 second로 접근할 수 있다.
* #include <utility> 에 있는데, algorithm, vector와 같은 헤더파일에서 이미 include 하고 있기 때문에 따로 include 하는 경우는 없다.
* make_pair를 이용하거나, 생성자를 이용해서 만들 수 있다.

[[app-listing]]
[source,c++]
.pair_example01.cpp
----
pair<int, int> p1;
cout << p1.first << ' ' << p1.second << '\n';

p1 = make_pair(10, 20);
cout << p1.first << ' ' << p1.second << '\n'

p1 = pair<int, int>(30, 40);
cout << p1.first << ' ' << p1.second << '\n'

pair<int, int> p2(50, 60);
cout << p2.first << ' ' << p2.second << '\n';
----

[[app-listing]]
[source,c++]
.pair_example02.cpp
----
pair<pair<int, int>> p = make_pair(make_pair(10, 20), make_pair(30, 40));
cout << p.first.first << ' ' << p.first.second << ' ';
cout << p.second.first << ' ' << p.second.second << '\n';

----

== tuple
* tuple은 pair와 같지만 여러 개를 묶을 수 있다
* .first, .second, .third, .fourth ... 가 아니고 get을 이용해서 인덱스로 접근해야 한다
* tuple은 #include <tuple>에 정의되어 있다

[[app-listing]]
[source,c++]
.tuple_example01.cpp
----
tuple<int, int, int> t1 = make_tuple(1, 2, 3);

cout << get<0>(t1) << ' ';
cout << get<1>(t1) << ' ';
cout << get<2>(t1) << '\n';

/*
for (int i=0; i<3; i++) {
    count << get<i>(t1) << '\n';
}
*/
----
* get<> 사이에 변수를 넣을 수는 없다
== tie
== vector
== deque
== list
== set 
== map
== stack
== queue
== priority_queue
== bitset
